name: Build and Test

on:
  push:
    branches:
      - '**'
  pull_request:
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event.number || github.sha }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

env:
  DOTNET_VERSION: '8.0.x'
  SOLUTION_FILE: SdkTestAutomation.sln
  CONFIGURATION: Release
  CONDUCTOR_SERVER_URL: "http://localhost:8080/api"
  CONDUCTOR_REPO: conductor-oss/conductor
  CONDUCTOR_BRANCH: main
  DOCKER_COMPOSE_FILE: docker/docker-compose.yaml

permissions:
  contents: read
  checks: write

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore NuGet Packages
      run: dotnet restore ${{ env.SOLUTION_FILE }}

    - name: Build Solution
      run: dotnet build ${{ env.SOLUTION_FILE }} --configuration ${{ env.CONFIGURATION }} --no-restore

    - name: Checkout Conductor Repository
      uses: actions/checkout@v4
      with:
        repository: ${{ env.CONDUCTOR_REPO }}
        ref: ${{ env.CONDUCTOR_BRANCH }}
        path: conductor

    - name: Start Conductor Services
      working-directory: conductor
      run: |
        docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d
        
        if ! docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps --services | grep -q "conductor-server"; then
          echo "ERROR: Failed to start conductor-server"
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} logs
          exit 1
        fi

    - name: Wait for Conductor to be ready
      working-directory: conductor
      run: |
        echo "Waiting for services to initialize..."
        sleep 30
        
        if ! docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps | grep -q "healthy"; then
          echo "ERROR: Services are not healthy"
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} logs
          exit 1
        fi
        
        timeout=200
        until (curl -s http://localhost:8080/api/health > /dev/null 2>&1) || \
              [ $timeout -le 0 ]; do
        
          if [ $((timeout % 30)) -eq 0 ]; then
            echo "Services status (${timeout}s remaining):"
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} logs --tail=20 conductor-server
          fi
          
          echo "Waiting for API... (${timeout}s remaining)"
          sleep 10
          timeout=$((timeout-10))
        done
        
        if [ $timeout -le 0 ]; then
          echo "ERROR: Conductor API failed to become healthy"
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} ps
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} logs conductor-server
          exit 1
        fi
        
        echo "SUCCESS: Conductor API is ready!"

    - name: Check Test Output Directory
      run: ls -la "SdkTestAutomation.Tests/bin/${{ env.CONFIGURATION }}/net8.0/"

    - name: Create Test Results Directory
      run: mkdir -p TestResults

    - name: Run Tests
      id: test-run
      run: |
        ./SdkTestAutomation.Tests/bin/${{ env.CONFIGURATION }}/net8.0/SdkTestAutomation.Tests \
          -html TestResults/test-results.html \
          -trx TestResults/test-results.trx \
          -jUnit TestResults/test-results.xml 2>&1
      continue-on-error: true

    - name: Install Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Convert HTML Report to Markdown
      if: always()
      run: |
        npm install -g html-to-markdown
        
        # Create a summary file
        echo "# Test Results" > TestResults/summary.md
        echo "" >> TestResults/summary.md
        echo "## Detailed Test Report" >> TestResults/summary.md
        echo "" >> TestResults/summary.md
        
        # Convert HTML to Markdown and append to summary
        if [ -f "TestResults/test-results.html" ]; then
          # Extract only the test results section (modify based on your HTML structure)
          sed -n '/<div class="test-results">/,/<\/div>/p' TestResults/test-results.html > TestResults/results-section.html
          html-to-markdown TestResults/results-section.html >> TestResults/summary.md
        else
          echo "No test results HTML file found." >> TestResults/summary.md
        fi
        
        # Add download link
        echo "" >> TestResults/summary.md
        echo "## Full Test Report" >> TestResults/summary.md
        echo "" >> TestResults/summary.md
        echo "ðŸ“Š [Download Full HTML Report](../suites/TestResults/test-results.html)" >> TestResults/summary.md

    - name: Publish Test Results (TRX)
      if: always()
      uses: dorny/test-reporter@v1
      with:
        name: Test Results (TRX)
        path: TestResults/test-results.trx
        reporter: dotnet-trx
        fail-on-error: true

    - name: Publish Test Results (JUnit)
      if: always()
      uses: dorny/test-reporter@v1
      with:
        name: Test Results (JUnit)
        path: TestResults/test-results.xml
        reporter: java-junit
        fail-on-error: true

    - name: Add Test Report to Job Summary
      if: always()
      run: cat TestResults/summary.md >> $GITHUB_STEP_SUMMARY

    - name: Upload Test Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results
        path: TestResults
        if-no-files-found: warn

    - name: Cleanup Conductor
      if: always()
      working-directory: conductor
      run: docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} down